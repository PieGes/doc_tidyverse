---
title: "tidyverse"
author: "Pierre Gestraud"
output:
  html_document: 
    toc: true
    toc_depth: 3
    number_sections: true
    theme: united
    toc_float: true
  github_document: default
  html_notebook: default
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, include = TRUE, fig.align = "center", out.width = "600px", cache = TRUE, autodep = TRUE)
require(tidyverse)
require(broom)
require(modelr)
require(gapminder)
```


# tidyverse

* `tidyverse` is a suite of packages that follow tidy philosophy
* initiated by Hadley Wickham
* http://tidyverse.org/

Packages in tidyverse:

- Core packages: `ggplot2`, `dplyr`, `tidyr`, `readr`, `purrr`, `tibble`
- Specialized data manipulation: `hms`, `stringr`, `lubridate`, `forcats`
- Data import: `DBI`, `feather`, `haven`, `httr`, `jsonlite`, `readxl`, `rvest`, `xml2`
- Modeling: `modelr`, `broom`

Warning: tidyverse function use mainly NSE (unquoted expressions)

## Tidy data

* each variable in the data set is placed in its own column
* each observation in the data set is placed in its own row
* each value is placed in its own cell

```{r, echo = FALSE}
knitr::include_graphics("images/tidy-1.png")
```

*Tidy Data, Hadley Wickham, JSS 2014*

## Tidy APIs

Functions should be **consistent** and  **readable**

- Take one step at a time
- Connect simple steps
- Consistency
    * almost all functions take `data.frame` as first argument and return a `data.frame`
    * all `stringr` functions take string as first argument
- Runs fast (use `RCPP`)    


# Data science workflow

```{r, echo = FALSE}
knitr::include_graphics("images/data-science.png")
```

# Data wrangling

```{r, echo = FALSE}
knitr::include_graphics("images/data-science-wrangle.png")
```

## Data import

```{r, out.width = "100px", fig.align = "center", echo = FALSE}
knitr::include_graphics("images/RStudio_Hex_readr.png")
```

* package `readr`
* `read_table`, `read_csv`, `read_delim`...
* compared to base functions, `readr` is much faster
* characters are never automatically converted to factors (i.e. no more stringsAsFactors = FALSE!)
* column names are left
* row names are never set
* create tibbles


```{r}
## write temporary file
tmp <- tempfile()
invisible(replicate(100,write.table(gapminder, file = tmp, append = TRUE, sep="\t", col.names = FALSE)))

```

```{r}
require(microbenchmark)
microbenchmark(base= read.table(tmp, sep="\t"), readr =  suppressMessages(read_delim(tmp, delim="\t", progress = FALSE)))
```


## tibbles

* main objects when working with tiydverse 
* package `tibble`
* new implementation of `data.frame`


tibbles vs data.frames:

* print
* subsetting with `$`: no partial matching, warning if access to non-existing column
* when creating, never change type of input, never change column names, never create rownames

```{r}
colnames(who) <- gsub("newrel", "new_rel", colnames(who))
who
who$coun
head(as.data.frame(who)$coun)
```

To preserve rownames, convert them to an explicit variable with `rownames_to_column`

```{r}
d <- data.frame(x=c("A", "B"), row.names = c("p1", "p2"))
d
as.tibble(d) 
rownames_to_column(d)
```




## tidyr



```{r, out.width = "100px", fig.align = "center", echo = FALSE}
knitr::include_graphics("images/RStudio_Hex_tidyr.png")
```

Help you to create **tidy data**.

* replace package `reshape2`
* convert wide data to long (`gather`)
* convert long data to wide (`spread`)
* merge variables into one (`unite`)
* split variable into several (`separate`)
* `nest`/`unnest` 
* `expand`, `crossing`, `nesting`

```{r, echo=FALSE}
knitr::include_graphics("images/tidyr.jpg")
```

```{r}
## wide to long
gather(who)

who_long <- gather(who, group, cases, -country, -iso2, -iso3, -year)
who_long <- na.omit(who_long)

who_long

## long to wide
spread(who_long, key = group, value = cases)

## separate
separate(who_long, col = group, sep = "_", into = c("new", "diag", "patient"))

who_long <- separate(who_long, col = group, sep = "_", into = c("new", "diag", "patient"), remove = FALSE)
```


## Data manipulation - dplyr

```{r, out.width = "100px", fig.align = "center", echo = FALSE}
knitr::include_graphics("images/RStudio_Hex_dplyr.png")
```

- package `dplyr`
- implements grammar of data manipulation

Single table verbs: 

* `arrange`
* `filter`
* `select`
* `mutate`
* `transmute`
* `summarise`

Apply operations by group with `group_by`.

Two-table verbs:

* Join tables (`full_join`, `right_join`, `left_join`, `inner_join`, `anti_join`)

### Single table verbs

#### Sort table rows with arrange


Sort rows according to **one variable**.

```{r}
arrange(who_long, cases)
```

Sort rows according to **several variables**. Sorting variables are separated by a comma, order of variables matters.

```{r}
arrange(who_long, cases, year)
arrange(who_long, year, cases)
```

To sort rows in **decreasing** order, use `desc`.

```{r}
arrange(who_long, desc(cases), year)
```



#### Filter rows  

`filter` is equivalent to `base::subset`

```{r}
filter(who_long, year <= 2000)
```

Multiple predicates separated by comma considered as `&`.

```{r}
filter(who_long, year <= 2000, country == "Afghanistan") 
## same as 
## filter(who_long, year <= 2000 & country == "Afghanistan") 
```

Or predicates separated by `|`.

```{r}
filter(who_long, country == "Palau" | cases == 230)
```

Usefull filter functions:

- `between`: shortcut for `x >= left & x <= right`

```{r}
filter(who_long, between(year, 1998, 2000))
```

- `near`: `==` with tolerance 

- `slice`: select rows by position

```{r}
slice(who_long, 10:15)
```

####  Columns selection and renaming


`select` allows to keep variables in a tibble. 

```{r}
select(who_long, country, cases, year) ## select columns by name
select(who_long, 2, 5) ## select columns by position
select(who_long, country:year) ## select columns by range on name
select(who_long, country, number = cases, year) ## select and rename column
```

Columns preceded by `-` are dropped.

```{r}
select(who_long, -group)
```

Special functions usefull in select:

- `starts_with`, `ends_with`, `contains`: stars, ends or contains a string
- `matches`: matches a regular expression

```{r}
select(who_long, starts_with("p")) ## starts_with string
select(who_long, contains("iso")) ## contains string
select(who_long, matches("r$")) ## regexp
```

Scoped selection and renaming. 

- `select_all` / `rename_all`: all variables
- `select_if` / `rename_if`: variables matching a predicate
- `select_at` / `rename_at`: som variables


```{r}
select_if(who_long, is.numeric)
```


```{r}
rename_all(who_long, toupper) ## rename all variables to upper case
```


#### Create new columns

`mutate` adds new columns, `transmute` adds new columns and drop existing.

```{r}
mutate(who_long, log_cases = log(1 + cases))
```

`mutate` can directly use new columns.

```{r}
mutate(who_long, log_cases = log(1 + cases), log_sqrt_cases = sqrt(log_cases))
```

Scoped mutation and transmuation.

- `mutate_if`
- `mutate_at`
- `mutate_all`

```{r}
mutate_if(who_long, is.character, toupper)
```

#### Summarise columns

`summarise` computes a single value. More usefull on grouped data (see later).

```{r}
summarise(who_long, m = mean(cases))
```

Usefull functions:

- `n`: count
- `n_distinct`: equivalent to `length(unique())`

```{r}
summarise(who_long, n_obs = n(), n_country = n_distinct(country))
```

Scoped summary:

- summarise_all
- summarise_at
- summarise_if

```{r}
summarise_if(who_long, is.numeric, mean) ## compute mean for every numeric column
```

Multiple functions can be given to `summarise` as list.

```{r}
summarise_if(who_long, is.numeric, list(mea = mean, med = median, v = var))
```

Columns can be selected in `summarise` as in `select` with the helpers functions (`starts_with`, `contains`...)

### Grouped operations

`dplyr` verbs can be used on a grouped data frame, allowing to perform operations separately on chunks of data. 

`group_by` defines the grouping variable(s).

```{r}
who_long_by_country <- group_by(who_long, country)
who_long_by_country
```

Summarising data by country:

```{r}
summarise(who_long_by_country, mean_cases = mean(cases), number = n())
```

Grouping on several variables:

```{r}
who_long_by_country_year <- group_by(who_long, country, year)
summarise(who_long_by_country_year, mean_cases = mean(cases))
```


Grouping can be cancelled with `ungroup`.

```{r}
ungroup(who_long_by_country)
```


### Two-tables verbs

Family of functions similar to `base::merge`.

```{r, out.width = "600px", fig.align = "center", echo = FALSE}
knitr::include_graphics("images/join-venn.png")
```


```{r}
d1 <- select(who_long, country, year, cases)
d2 <- select(who_long, country, year, iso2)
full_join(d1, d2)
```

dplyr              | merge
-------------------|-------------------------------------------
`inner_join(x, y)` | `merge(x, y)`
`left_join(x, y)`  | `merge(x, y, all.x = TRUE)`
`right_join(x, y)` | `merge(x, y, all.y = TRUE)`,
`full_join(x, y)`  | `merge(x, y, all.x = TRUE, all.y = TRUE)`



- `semi_join(x, y)` keeps all observations in x that have a match in y.
- `anti_join(x, y)` drops all observations in x that have a match in y

## Programming - magrittr

"Ceci n'est pas un pipe"

```{r, out.width = "100px", fig.align = "center", echo = FALSE}
knitr::include_graphics("images/RStudio_Hex_pipe.png")
```

* `magrittr` introduce new pipe operator: `%>%`
* makes code more readable
* provides aliases (`extract`, `add`, `equals`, `set_colnames`...)

```{r, out.width = "400px", fig.align = "center", echo = FALSE}
knitr::include_graphics("images/magrittr_idea.png")
```

```{r}
## summarise(group_by(who_long, country), number = n(), m = mean(cases))
who_long %>% group_by(country) %>% summarise(number = n(), m = mean(cases))
who_long %>% 
    filter(year <= 2000) %>% 
    group_by(country) %>% 
    summarise(number = n(), m = mean(cases))
```

* `magrittr` gives to LHS function the result of RHS as first argument
* use `.` to put RHS result somewhere else

```{r}
who_long <- mutate(who_long, gender = substr(patient, 1, 1))
who_long %>% lm(cases ~ gender, data = .)
```



## purrr

* `purrr` works on lists
* family of `map` functions replace `lapply` 
* control over output type

```{r}
iris %>% select(-Species) %>% map(mean)
iris %>% select(-Species) %>% map_df(mean)
iris %>% select(-Species) %>% map_dbl(mean)
iris %>% map_if(is.numeric, mean)
```

* `flatten`
* `transpose`

# Data visualisation

* `ggplot2` 
* perfectly integrated in workflow

```{r}
who_long %>% 
    filter(year >= 2000) %>% 
    group_by(country, year) %>% 
    summarise(m = mean(cases)) %>% 
    ggplot(aes(x = year, y = m, group = country)) + geom_line()
```

# Model

```{r, out.width = "600px", fig.align = "center", echo = FALSE}
knitr::include_graphics("images/data-science-model.png")
```

## broom

```{r, out.width = "100px", fig.align = "center", echo = FALSE}
knitr::include_graphics("images/rstudio-hex-broom.png")
```

* `broom` makes tidy data from models
* `glance`: model summary
* `tidy`: information about coefficients
* `augment`: information about observations
* support for large number of models (`lm`, `glm`, `lme4`, `gam`, `anova`, `nls`, `kmeans`, `arima`...)

```{r}
mod <- lm(Sepal.Length ~ Petal.Length, data = iris)
glance(mod)
tidy(mod)
augment(mod) %>% head
```


And for bioinformatics? Use `biobroom`! (https://www.bioconductor.org/packages/release/bioc/html/biobroom.html)

## modelr

* package `modelr` to work with models and data.frame
* `add_predictions`
* `add_residuals`

```{r}
iris %>% add_residuals(mod) %>% add_predictions(mod) %>% head
```


## Many models

* create a nested data.frame

```{r}
gap_by_country <- gapminder %>% 
    group_by(country, continent) %>% 
    nest
```
* column data is a `list`

* compute model for each country
```{r}
gap_by_country <- gap_by_country %>% mutate(mod = map(data, ~lm(lifeExp ~ year, data = .)))
```

* models and data are stored together

* now add information about model
```{r}
gap_by_country %>% 
    mutate(glance = map(mod, glance)) %>% 
    unnest(glance) %>% 
    arrange(r.squared)

## find bad quality models
gap_by_country %>% 
    mutate(glance = map(mod, glance)) %>% 
    unnest(glance) %>% 
    filter(r.squared <= 0.1)
```


```{r}
gap_by_country %>% 
    mutate(augment = map(mod, augment)) %>% 
    unnest(augment) %>% 
    ggplot(aes(x = year, y = .fitted, group = country)) + geom_line() + facet_wrap(~continent)
```

```{r}
gap_by_country %>% 
    mutate(tidy = map(mod, tidy)) %>% 
    unnest(tidy) %>% 
    filter(term == "year") %>% 
    ggplot(aes(x = continent, y = estimate)) + geom_boxplot()
```

# Data type specific packages

## Strings

```{r, out.width = "100px", fig.align = "center", echo = FALSE}
knitr::include_graphics("images/RStudio_Hex_stringr.png")
```

* package `stringr`
* enhances base functions for strings manipulations
* functions `str_`*

## Dates

```{r, out.width = "100px", fig.align = "center", echo = FALSE}
knitr::include_graphics("images/RStudio_Hex_lubridate.png")
```

- package `lubridate`
- enhances base functions for dates and times manipulations
- `ymd`, `year`, `month`, `day`, `round_date`, `floor_date`

## Factors


```{r, out.width = "100px", fig.align = "center", echo = FALSE}
knitr::include_graphics("images/forcats.png")
```

* package `forcats`
* change levels, order...

## A package to rule them all

- package `tidyverse`
- install all packages of tidyverse
- when loaded, attach only some packages

# Ressources

- R4ds (http://r4ds.had.co.nz/)
- rstudio cheatsheet